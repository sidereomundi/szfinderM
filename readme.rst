.. container:: header

   SZ-Cluster-Finder -- Map-based Approach

.. contents:: Table of Contents
   :class: sidebar
   :depth: 2

.. container:: abstract

  This is map based sz cluster finder source code.
  The approach is based on Melin 2006.
  The noise term is estimated from the map.

Work Flow : SPT simulator
*************************

create beam profile
===================

  The beam profile is based on the mean of 1000 realizations of beam
  profiles generated by Tom (`SPT beam Realizations`_).

  We convert this cl file to 2D fits file according to the map
  resolution for further usage.

  >>> mksptbeam <cl file> <output> [beam_norm = 1] [pixel_size = 0.190430 (arcmin)]

  >>> mksptbeam ../data/sptbeam150_cl_mean.dat beam150 0.772
  >>> mksptbeam ../data/sptbeam95_cl_mean.dat beam95 0.661

  The test beam profiles are stored at `result/beam<freq>test.fits`
  and using checkbeam.py we get the comparison here:
  
  >>> checkbeam.checkbeambuild(freq,fwhm)

    - `150 GHz beam (FWHM 1.1 arcmin) <result/check_beam150.png>`_
    - `95 GHz beam (FWHM 1.6 arcmin) <result/check_beam95.png>`_


create CMB + Ysz map
====================

   + The CMB map is created by subroutine `sub_mkcmb.c`.  And the
     output is tested by `checkmap.py`.   By setting **OUTPUT_CMB=1**
     will generate the raw CMB temperature map for checking `cmb.fits`.
     This CMB compares to the input cl file is here at `CMB_comparison
     <result/cmbcmp.png>`_

   + The Ysz is added by `sub_mkbolo.c/addysz()`.
     Because the CMB temperature is defined as (Planck 2013 I)

     :math:`\Delta T_\text{CMB} = \Delta I_\nu/(dB_\nu/dT)_{T_0}`

     such that the Ysz's imprint is (Planck 2013 XXI)

     :math:`\Delta T_\text{CMB} = g(\nu)\ y \ T_\text{CMB}`

     where :math:`g(\nu) = x \coth(x/2)-4` and :math:`x=h\nu/k_bT_\text{CMB}`.

Band pass filtering and beam effect
===================================

   + The SPT beam is based on `create beam profile`_.

   + An extra high-l pass filtering is from
     `spt:/data/tcrawfor/tfs_for_r13/` located at data/

   We build a synthetic beam by combining those two filters above
   first and the apply the synthetic beam to the previous CMB+Ysz map.

   The flow to build synthetic beam is following:

      - convert 3360x3360 filter to 4096x4096 filter
      
          >>> python checktf.py tf_150_nobeam.fits tf150.fits
	  >>> python checktf.py tf_90_nobeam.fits tf95.fits

	  (tf150.fits is the 2D image of transfer function in
	  3360x3360 pixelization).

	  Then under IDL 

	      >>> 
	      beam = mrdfits('tf150.fits')
   	      beam = congrid(beam,4411,4411,/interp,/cubic)
	      beam = beam[157:4252,157:4252]
    	      mwrfits,beam,'tf150L.fits',/create

	  (tf150L.fits is transfer function in 4096x4096
	  pixelization).

	  After that, use python again to shift the beam into regular
	  coordinates.  (output to tf150L2.fits, which must be not existed.)

	  >>> python checktf.py tf150L

      - use tf150L2.fits to build synthetic beam (`beam150T*`)
      
          >>> mksynbeam <beam> <tf> <output[no .appendix] 

	  >>> mksynbeam beam150_fft.dat tf150L2.fits beam150T
	  >>> mksynbeam beam95_fft.dat tf95L2.fits beam95T

Foreground noises addition
==========================

   + White Noise for SPT

         ===========  =========================  =====================
	 Freq[GHz]    White Noise [uK-arcmin]     Beam Normalization
	 ===========  =========================  =====================
	 150          18                          0.772
	 95           44                          0.661
	 ===========  =========================  =====================

   + Other noise (PSD) is available here `<http://pole.uchicago.edu/public/data/maps/ra5h30dec-55/spt_psds_ra5h30dec-55_2008_sfl.html>`_

Final output
============

+ **mkoneszmap <ysz_map> <frequency[GHz]> <Noise [uK-arcmin]> <beam_profile [no .appendix]> <output[no .fits]> [rseed_cmb] [rseed_noise]**

   >>> mkoneszmap wmap.a.fits 95 44. beam95T mock95 -1234 -224261
   >>> mkoneszmap wmap.a.fits 150 18. beam150T mock150 -1234 -2391

   .. note:: Same CMB rseed returns same CMB temperature maps for
             different frequencies.

+ Check `SPT mock map powerspectrum`_ for detail comparison.

+ Products in hand

  - beam*.fits/_fft.dat : initial beam without transfer function (SPT average)
  - tf*L2.fits : rescaled transfer function in 4096x4096 pixils
  - beam*T.fits/_fft.dat : realistic beam profiles
  - mock*.fits : mock maps

Work Flow : cluster finder
**************************

Single frequency filter
=======================

+ Fundation

  The single frequency filter is based on Melin 05:

  :math:`f(k) = \sigma_{\theta_c}^2 \frac{F_c(k)}{P_N(k)}`

  where 
  :math:`F_c(k) = j_\nu y_{\theta_c}(k)\times b(k)`, with
  :math:`j_\nu` frequency dependence of Ysz signiture,
  :math:`y(k)` is the cluster profile in Fourier space,
  :math:`b(k)` is the beam profile and 
  :math:`P_N(k)` is the noise spectrum.

  And the r.m.s of the filtered map is:
  
  :math:`\sigma_{\theta_c}^2 = \int d^2k F_c(k)^{t} P^{-1} F_c(k)`

  The filtering is processed as

  :math:`\hat y(x0) = \int d^2x f(x-x_0)\times m(x)`, such as
  :math:`\hat y(k) = \int d^2k f(k)\times m(k)`,

  where :math:`m` is the observed map.

  .. note::  the 0 frequency mode need to be manually removed!

+ Filter profile comparison


  The difference between the map-based filter vs. previous cl-based
  filter is:

    * map-based filter:  the :math:`P_N` is measured directly from map.
    * cl-based filter: the :math:`P_N =
      P^{astro}\times|B|^2+P_{white-noise}`.

  Here is the `comparison of single frequency filter
  <result/cmpFilter.png>`_.  (created by checkfilter.py)


  Also, the map-based filter is noisy, so we averaged the noise
  powerspectrum in k-space before filtering. (Just average two
  elements with same distance to the origin.)

  Here is the `comparison of w/o averaging
  <result/cmpFilter_AVG.png>`_. (created by checkfilter.py)

+ Filter result comparison

  >>> filter <map .fits> <beam fft.dat> [output (no .fits)]
      [theta_core (arcmin)]

  The comparison detail is at `Single frequency comparison <result/cmp/cmp.rst>`_

Multi-frequency filter
======================

+ Fundation

  The multi-frequency filter shares the same equation with single
  frequency one with scalers replaced by vectors corresponds to
  frequencies.

+ Filter profile comparison

  The main comparison is focusing on cl-based approach, azimuthal
  averaged map based approach, and pure map based approach.


Filter in Arnaud profile
========================

Update with Arnaud profile based on a conversion between r500 and r_core.
There is a switch in declare.h.
Refer to workplanAug12.org

Code
****

C code
======

  - Make SPT beam based on `SPT beam Realizations`_

    >>> mksptbeam <cl file> <output> [beam_norm=%8lf] [pixel_size=%8lf arcmin]
 
  - Make SPT beam + transfer function -> `Band pass filtering and beam effect`_

  - Make one SPT mock sky

    >>> mkoneszmap <ysz_map> <frequency[GHz]> <Noise [uK-arcmin]> <beam_profile [no .appendix]> <output[no .fits]> [rseed_cmb] [rseed_noise]

Python tools
============

  Located under tools/ directory with document

  - checkmap.py
  - checkbeam.py
  - checkfreq.py
  - checkfilter.py





Data
****
  
  Located under data/ directory

SPT beam Realizations
=====================

  SPT beam profile is 
  downloaded `SPT_Beam
  <http://pole.uchicago.edu/public/data/crawford13/#Beam
  Realizations>`_

  The files are stored at desproc1:~jiayiliu/szfinderMap/data as
  
  + spt_beam_realizations_95ghz.fits
  + spt_beam_realizations_150ghz.fits
  + spt_beam_realizations_220ghz.fits

  The mean profiles are calcuated by checkbeam.py and stored as **sptbeam<freq>_cl_mean.dat**.
  

SPT frequency response
======================

 The SPT frequency responces are through private communication with
 Brad. 

 - `spt_band_2008_150ghz_dr1.txt <result/freq_eqv_150.png>`_
 - `2009_90_band.ascii.txt  <result/freq_eqv_95.png>`_

 The links shows the frequencies responces with arbitrary normalization.

SPT timeseries transfer function
================================

 The SPT timeseries transfer functions are through private
 communication with Tom.
 
    I've created filter transfer functions appropriate for the Reichardt et al. (2013) cluster maps (and the new cluster run) and put them in spt:/data/tcrawfor/tfs_for_r13/. Alex and Jiayi, I think you want just the part that corresponds to the timestream filtering, and those are in the files called "tf_150_nobeam.fits" and similar. Brad, I'm assuming you're interested in the tfs with the beam, and those are in "tf_150.fits" and similar. These are 2d fourier-domain functions with idl-style fourier ordering. As written, the arrays are 3360x3360, which is the size of the ra23h30dec-55 map, but to use them with a different-sized map, just reshape them (I would use congrid(tf,new_nx,new_ny) in idl).

Result
******

SPT equivalent frequency
========================

  Given the frequency responce :math:`n(\nu)`, the equivalent
  wavelength for each band is calculated as

  :math:`\nu_{eq} = \frac{\sum g(h\nu_i/kT) * n(\nu_i)}{\sum
  n(\nu_i)}`


  We get the result from checkfreq.py as following (Tcmb=2.7255K):

  =======   ==============
   Band      Equiv. Freq.
  =======   ==============
   150        153.80 GHz
   95         93.79 GHz
  =======   ==============



SPT mock map powerspectrum
==========================

The final cl distribution of mock map of 150 GHz is at `SPT Mock cl plot <result/mock_cl.png>`_.


.. container:: footer

   Maintained by Jiayi Liu with Restructured text.
   For better performance: direct mathjax with
   *path_to*"mathjax/MathJax.js?config=default" instead of using CDN.
