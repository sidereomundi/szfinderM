"""Binary FFT helpers shared by the Python translations."""

from __future__ import annotations

from pathlib import Path

import numpy as np


def fft_filename(stem: str | Path) -> Path:
    """Mimic the filename mangling performed by ``fftsave``."""

    stem_path = Path(stem)
    name = stem_path.name
    if name.endswith(".dat") and name.endswith("_fft.dat"):
        return stem_path
    if name.endswith(".dat"):
        new_name = f"{name[:-4]}_fft.dat"
    else:
        new_name = f"{name}_fft.dat"
    return stem_path.with_name(new_name)


def save_fft(image: np.ndarray, destination: str | Path) -> None:
    """Replicate ``fftsave`` using :func:`numpy.fft.rfft2`."""

    fft_result = np.fft.rfft2(image.astype(np.float64, copy=False))
    fft_path = fft_filename(destination)
    fft_data = np.ascontiguousarray(np.asarray(fft_result, dtype=np.complex128))
    expected = image.shape[0] * (image.shape[1] // 2 + 1)
    if fft_data.size != expected:
        raise RuntimeError("Unexpected FFT output size compared to the input map dimensions.")
    fft_path.write_bytes(fft_data.tobytes())


def load_fft(path: str | Path, nsidepix: int) -> np.ndarray:
    """Load a Fourier-space beam generated by :func:`save_fft`."""

    location = Path(path)
    fft_data = np.fromfile(location, dtype=np.complex128)
    expected = nsidepix * (nsidepix // 2 + 1)
    if fft_data.size != expected:
        msg = (
            f"The size of {location} is incorrect: {fft_data.size * fft_data.itemsize} bytes "
            f"for {expected} complex numbers"
        )
        raise ValueError(msg)
    return np.ascontiguousarray(fft_data.reshape(nsidepix, nsidepix // 2 + 1))
